package org.jooq.mcve.test.java.oracle;

import apackage.AnObject;
import com.fasterxml.jackson.databind.json.JsonMapper;
import org.jooq.Converter;
import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;
import org.jooq.mcve.java.oracle.Tables;
import org.jooq.mcve.java.oracle.tables.records.TestRecord;
import org.jooq.tools.JooqLogger;
import org.junit.*;
import org.testcontainers.containers.OracleContainer;
import org.testcontainers.containers.wait.strategy.HostPortWaitStrategy;
import org.testcontainers.containers.wait.strategy.LogMessageWaitStrategy;
import org.testcontainers.containers.wait.strategy.WaitAllStrategy;
import org.testcontainers.utility.DockerImageName;
import org.testcontainers.utility.ResourceReaper;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;

import static org.jooq.mcve.java.oracle.Tables.T1;
import static org.jooq.mcve.java.oracle.Tables.T2;
import static org.jooq.mcve.java.oracle.Tables.TEST;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

public class JavaTest {

    static JooqLogger      log = JooqLogger.getLogger(JavaTest.class);
    static OracleContainer db;
    static Connection      connection;
    static DSLContext      ctx;

    @BeforeClass
    public static void init() throws SQLException {
        if (System.getProperty("jooq.codegen.jdbc.url") == null) {
            db = new OracleContainer(DockerImageName.parse("gvenzl/oracle-free").asCompatibleSubstituteFor("gvenzl/oracle-xe")) {
                @Override
                public String getSid() {
                    return "FREEPDB1";
                };

                @Override
                public String getDatabaseName() {
                    return "FREEPDB1";
                };
            }
                .withUsername("MCVE")
                .withPassword("MCVE")
                .withEnv("ORACLE_PASSWORD", "MCVE")
                .withEnv("APP_USER", "MCVE")
                .withEnv("APP_USER_PASSWORD", "MCVE")
                .waitingFor(new WaitAllStrategy()
                    .withStrategy(new LogMessageWaitStrategy()
                        .withRegEx(".*DATABASE IS READY TO USE!.*"))
                    .withStrategy(new HostPortWaitStrategy())
                    .withStartupTimeout(Duration.ofMinutes(5))
                )
                .withInitScript("db/migration/init.sql");
            db.start();
            System.setProperty("jooq.codegen.jdbc.url", db.getJdbcUrl());
            System.setProperty("jooq.codegen.jdbc.username", db.getUsername());
            System.setProperty("jooq.codegen.jdbc.password", db.getPassword());
        }

        log.info("Connecting");
        connection = DriverManager.getConnection(
            System.getProperty("jooq.codegen.jdbc.url"),
            System.getProperty("jooq.codegen.jdbc.username"),
            System.getProperty("jooq.codegen.jdbc.password")
        );

        ctx = DSL.using(connection, SQLDialect.ORACLE);

        // Use JDBC directly instead of jOOQ to avoid DEBUG logging all of this
        try (Statement s = connection.createStatement()) {
            log.info("Finished setup");
        }
    }

    @AfterClass
    public static void end() {
        if (db != null) {
            ResourceReaper.instance().stopAndRemoveContainer(db.getContainerId(), db.getDockerImageName());
        }
    }

    @Before
    public void setup() throws Exception {
        ctx.delete(TEST).execute();
    }

    @After
    public void after() throws Exception {
    }

    @Test
    public void mcveTest() {
        ctx.configuration().set( new org.jooq.ConverterProvider() {
            private static final JsonMapper JSON_MAPPER = new JsonMapper();

            @SuppressWarnings( { "unchecked", "rawtypes", "serial" } )
            public <T, U> Converter<T, U> provide(Class<T> tType, Class<U> uType ) {
                if( tType.equals( String.class ) && uType.equals( AnObject.class ) ) {
                    return new org.jooq.impl.AbstractConverter( tType, uType ) {

                        @Override
                        public Object from( Object databaseObject ) {
                            if( databaseObject == null ) return null;
                            try {
                                return JSON_MAPPER.readValue( databaseObject.toString(), uType );
                            } catch( IOException e ) {
                                throw new UncheckedIOException( e );
                            }
                        }

                        @Override
                        public Object to( Object userObject ) {
                            if( userObject == null ) return null;
                            try {
                                return JSON_MAPPER.writeValueAsString( userObject );
                            } catch( IOException e ) {
                                throw new UncheckedIOException( e );
                            }
                        }

                    };
                }

                return null;
            }
        } );

        AnObject deletedEntry = ctx.deleteFrom(T1 )
                .where( T1.ID.eq( BigDecimal.ONE ) )
                .returning( T1.JSON )
                .fetchOne( T1.JSON );

        System.out.println(deletedEntry);
    }

    @Test
    public void mcveTestEquals() {
        assertTrue("eq() - check", ctx.fetchExists(T2, T2.V.eq( "anotherEntry" ) ));
        assertTrue("equal() - check", ctx.fetchExists(T2, T2.V.equal( "anotherEntry" ) ));
        assertTrue("ne() - check", ctx.fetchExists(T2, T2.V.ne( "anotherEntry" ) ));
        assertTrue("notEqual() - check", ctx.fetchExists(T2, T2.V.notEqual( "anotherEntry" ) ));
    }
}
